---
title: HTTP 缓存
tags:
- http
- 缓存
desc: http 缓存
layout: post
---

**浏览器的缓存机制分为两块，也就是规范中的 4.2 Freshness 和 4.3 Validation**

## Freshness
`Cache Control` 与 `Expires` 是一组，他们是用来进行 Freshness 验证，也就是提供客户端检测文件是否足够新鲜，可以无需向服务端发起 Validation 请求就能保证并未过期可以直接使用。
所有的 from cache 的请求实际上都是由于浏览器认为本地的缓存资源足够新鲜，所以无需额外请求而直接使用。
<!-- more -->
#### 历史问题
为何有两个参数而不是一个参数是由于历史原因，在 HTTP 1.0 中定义的是 Expires，Expires 的值是一个明确的过期时间，而后来使用中发现一旦客户端的时间与服务器时间不一致就会引发很多缓存问题。
因此在 HTTP 1.1 中新添加了 Cache Control，实现了更优的文件过期声明，比如 max-age 配置，是一个 timespan，告知客户端这个文件多长时间不会过期而不是直接告知过期时间。

## Validation
`Last-Modified` 和 `ETag` 则是另一组控制信息，他们用来实现 Validation。他们的职责是在本地缓存被浏览器判断可能不够新鲜的时候，会用这两组信息向服务器请求数据，如果服务器内容没有改变，那么约定服务器会返回 304 HTTP Code 表明这个缓存可以直接使用，无需重新拉取，而一旦服务器内容改变了就会返回 200，同时返回新的文件内容。

#### 历史问题
至于为何有两组字段来解决这个问题依然是历史问题，在 HTTP 1.0 中约定的是 Last-Modified，他代表的含义是文件最后一次修改的时间，那么这种约定带来的问题是一旦内容是动态生成的，这个时间在服务端不一定可以正确的生成，其次是 Last-Modified 只有秒级的精度，如果在一秒内有一次以上的文件修改，这样的缓存就会造成额外的问题。
因此 HTTP 1.1 中新引入了 ETag，他的实现不尽相同，对于动态内容，常规做法是对动态内容做 HASH 计算，作为 ETag 返回，对于静态资源，一般是使用 inode+mtime 进行计算。

#### 额外的问题
ETag 也有他自己的问题，例如，同一个文件在不同物理机上的 inode 是不同的，这就导致了在分布式的 Web 系统中，当访问落在不同的物理机上时会返回不同的 ETag，进而导致 304 失效，降级为 200 请求。解决办法也有从 ETag 算法中剥离 inode，只使用 mtime。

### Ref
[配置错误产生的差距：200 OK (FROM CACHE) 与 304 NOT MODIFIED #2](https://div.io/topic/854)
[浅谈浏览器http的缓存机制](https://www.cnblogs.com/vajoy/p/5341664.html)
